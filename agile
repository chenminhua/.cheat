# 敏捷宣言
个体和交互 胜过 过程和工具
可以工作的软件 胜过 面面俱到的文档
客户合作 胜过 合同谈判
响应变化 胜过 遵循计划

# 敏捷原则
尽早的，持续的交付有价值的软件
欢迎改变需求
经常性交付
业务人员和开发人员在一起工作
围绕被激励起来的个体构建项目，给他们支持和信任
最有效的交流方式就是面对面
工作的软件是首要的进度衡量标准
可持续的开发速度，don't burn out
关注优秀的技能和好的设计
简单是根本
最好的架构，需求和设计出自自组织的团队
定期反省和调整

# 面向对象设计原则
SRP 单一职责原则
OCP 开放封闭原则  软件实体应该是可以扩展的，但不可以修改
LSP 里氏替换原则
DIP 依赖倒置原则  抽象不依赖细节，细节依赖于抽象
ISP 接口隔离原则  不应该强迫客户依赖于他们不用的方法，接口属于客户
REP 重用发布等价原则
CCP 共同封闭原则  包中的所有类对于同一类型的变化是共同封闭的
CRP 共同重用原则
ADP 无环依赖原则
SDP 稳定依赖原则
SAP 稳定抽象原则

# 极限编程
完整团队，计划游戏，客户测试，简单设计，结对编程，测试驱动，改进设计，持续集成，集体代码所有权，编码标准，使用隐喻，可持续的速度。

# 设计模式
学会抵制模式的诱惑，避免带来不必要的复杂性

# 本书四个重点
敏捷方法，面向对象设计原则，设计模式，UML








# 第一部分 敏捷开发
## 敏捷实践
没有文档的项目是一场灾难，但是过多的文档比过少的文档更糟糕。直到迫切需要且意义重大时才来编写文档

## 极限编程
每次迭代计划大概两周，每六个迭代需要一个发布计划。
编写测试用例和代码之间的更迭速度是很快的，测试用例和代码共同演进。
集体代码所有权。不要限制每个人的发展。
设计应当尽可能简单，在明确需要一个基础结构前，不要引入它。
重构是持续进行的，是每隔一个小时或半个小时就要去做的事情。

## 计划
计划游戏的本质是划分业务人员和开发人员之间的职责，业务人员确定feature的重要性，开发人员确定feature代价

## 测试驱动
编写测试是一种验证行为，更是一种设计行为。同样也是一种编写文档的行为。避免了相当数量的反馈循环。
编写测试可以迫使我们使用不同的观察点。
测试促使模块之间的隔离。

## 重构
软件三大职责：可运行，可应对变化，可理解和沟通

## 一次实践











# 第二部分 敏捷设计
什么是敏捷设计
 什么是拙劣的软件设计:
     僵化，设计难于改变
     脆弱，设计易于破坏
     immobility: 难于重用
     viscosity: 难以做正确的事
     过分设计: 不必要的复杂性
     opacity: 晦涩，混乱的表达

源代码就是设计！？

重新设计很少会成功。虽然设计人员开始时是出于好意，但是他们发现自己正在朝着一个移动的目标射击。老系统不断发展变化，而新的设计必须跟上这些变化。

【什么是软件设计，reeves论文】

什么激发了软件的腐化？
需求是项目中最不稳定的因素，需求没有按照初始设计预见的方式进行变化。
如果我们的设计由于需求变化而退化，那么我们就不是敏捷的。

单一职责原则 SRP
就一个类而言，应该仅有一个引起它变化的原因。
game类保持跟踪每一轮比赛的职责，scorer类负责计算比赛的得分
计算矩形几何面积和在GUI上画出矩形也应该在两个不同的类中。
职责可以定义为“变化的原因”，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。



开放封闭原则 OCP
软件实体应该是可以扩展的，但是不可修改。
怎样才能在不改动模块源代码的情况下更改其行为呢？？关键是抽象。
模块可以操作一个抽象体，由于模块依赖于一个固定的抽象体，所以对它的更改可以是关闭的；同时，从这个抽象体也可以扩展模块行为。

预测变化和贴切的结构。

```
Interface Shape {
    draw()
}
class Square implements Shape {
    draw()
}
class Circle implements Shape {
    draw()
}
DrawAllShape([shapes]) {}
```

## 如何去隔离变化呢？在可能发生变化的地方放置钩子，但是只在需要的时候去放置。

## 使用抽象获得显式封闭

## 使用数据驱动的方式获得封闭性（数据与代码的界限）



里氏替换原则 LSP

子类型必须能够替换掉它们的基类型。
违反里氏替换原则往往也违反了OCP原则。
一个经典的例子：正方形和长方形。
基于契约设计(DBC, design by contract)



依赖倒置原则 DIP
高层模块不应该依赖于低层模块，二者都应该依赖于抽象。
抽象不应该依赖于细节，细节应该依赖于抽象。
倒置不仅仅是依赖的倒置，也是接口所有权的倒置，当使用DIP时，往往是用户拥有接口，而服务者则从这些抽象接口派生。
这就是著名的hollywood原则：不要调用我们，我们会调用你（don't call us, we will call you）。
依赖于抽象！
把不稳定的类隐藏在抽象的接口后面，可以隔离类的不稳定性。

什么是高层策略呢？它是应用背后的抽象，是那些不随具体细节改变而改变的真理。它是系统内部的系统，它是隐喻。
在按钮和台灯的例子中，背后的抽象就是检测用户的指令并将其传给目标对象。



接口隔离原则 ISP
分离客户就是分离接口。
door接口和timerClient接口是被完全不同的客户使用的，timer使用timerClient,
操作门的类使用door，既然客户程序是分离的，接口也应当分离。因为肯程序对它们使用的接口施加有作用力。

不应该强迫用户依赖它们不用的方法。
可以使用委托分离接口。Timer -> DoorTimerAdapter -> TimedDoor

155页，ATM UI接口



# 第三部分 案例研究

# COMMAND模式和active object模式
sensor无需去触发继电器的开关，当sensor检测到事件发生，就触发其绑定的command的do方法，do方法决定其需要进行的操作。

command的另一个常用场景是事务操作
command模式可以实现验证与执行在实体上解耦和时间上解耦
undo操作

# template method模式和strategy模式
bubble Sort的例子
applicationRunner的例子（sort）

# facade模式和mediator模式
当想要为一组复杂且全面的接口的对象提供一个简单且特定的接口时，可以使用facade模式。（隐藏复杂接口，只暴露你需要的）
mediator模式则是对用户隐藏的（我需要一个例子）

# singleton模式和monostate模式

# null object模式



# 包的设计原则
包的内聚性原则：重用发布等价原则，共同重用原则，共同封闭原则
重用发布等价原则：
共同重用原则：如果我依赖了包中的一个类，我就应该依赖其所有的类
共同封闭原则：如果两个类会一起变化，它们就应当在一个包中，一个包变化的时候不应该影响其他包。

包的耦合性原则：无环依赖原则，画出你的依赖关系图！

包的设计不适合自顶向下设计，而是随着代码的扩展，从既有代码中分离出来的。
很可能改变的包不应该被基本不变的包依赖。
OCP原则告诉我们，我们需要那些无需修改就可以扩展的类---抽象类。

稳定抽象原则： 包的抽象程度应该和其稳定程度一致。一个稳定的包应该是抽象的！


# factory模式
factory模式允许我们只依赖抽象接口就能创建具体对象的实例，在开发过程中，如果具体类高度易变，那么这个模式就很有用。
```
public interface ShapeFactory {
    public Shape make(String shapeName)
}

public class ShapeFactoryImplementation implement ShapeFactory {
    public Shape make(String shapeName){
        //if else ...
    }
}
```

使用工厂的一个主要好处是可以报工厂的一种实现替换为另一种实现。

使用工厂会带来复杂性，但是也带来了很多好处（DIP）,如果要使用proxy模式，或者需要欺骗单元测试，可以考虑使用工厂模式。

# composite模式



# observer模式
push me to pull you

最大动力来自OCP。增加新的观察者时无需改动被观察者的对象，这样被观察者对象就可以保持封闭。
同时，clock可以替换subject, digitalClock可以替换Observer，符合LSP。
另外，observer模式帮助我们倒置了依赖。


# abstract server模式
switch, switchable, light
switch依赖了switchable,light实现了switchable
注意，switchable属于客户（switch），而不是其派生类(light)



# adapter模式
switch, switchable, light adapter, light




# bridge模式



# proxy模式
倒置应用程序和层之间的依赖关系，在使用数据库的应用中，它使得应用程序不必知道数据库模式的知识；在使用中间件的应用中不必知道中间件的数据类型。
应用程序没有依赖代理，相反的是代理会依赖应用程序和api。
代理是一个非常重型的解决方案，大多数时候都不应该使用。



# UML (P438)


