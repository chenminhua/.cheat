汇编语言：二进制指令的文本形式

寄存器：cpu只负责运算，不负责存储数据，数据存在cpu缓存中。但是cpu缓存不够快，因此cpu还自带了寄存器，用来存储最常用的数据。那些最频繁读写的数据（比如循环变量），都会放在寄存器中。寄存器不依靠地址区分数据，而依靠名称。每个寄存器都有自己的名称。

早期的x86 cpu只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，且都是通用寄存器，不指定特别用途。但是早期寄存器的名字都保留了下来： EAX,EBX,ECX,EDX,EDI,ESI,EBP,ESP。其中ESP寄存器特定用于保存当前栈的地址。

32位cpu的寄存器大小就是4个字节，64位则是8个字节。

内存模型：程序运行时，操作系统会给它分配一段内存，用来存储程序和运行产生的数据。这段内存有起始和结束地址，比如0x1000到0x8000。程序运行过程中，对于动态的内存占用请求（新建对象，malloc等），系统会从预先分配好的堆内存中划分出一部分给用户。堆内存不会自动消失，必须手动释放，或者由垃圾回收机制来回收。而栈则是由函数运行而临时占用的内存区域。当一个函数返回时，器栈帧就会被回收，释放内部变量。

# cpu指令

int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}

gcc -S example.c

_add_a_and_b:
    push %ebx             将ebx这个寄存器里的值写入这个帧，esp减去4，即栈使用4个字节
    mov  %eax, [%esp+8]   这里是将2写入寄存器eax
    mov  %ebx, [%esp+12]  将3写入寄存器ebx
    add  %eax, %ebx       计算2+3
    pop  %ebx             取出stack最近写入的值，将其写回ebx寄存器，esp增加4，即栈释放4个字节
    ret                   终止当前函数，当前函数的栈帧被回收

_main:
    push 3      将3放入栈
    push 2      将2放入栈
    call _add_a_and_b    调用函数add_a_and_b,并为其建立一个新的帧
    add %esp, 8          由于add_a_and_b结束，栈再释放8个字节
    ret


