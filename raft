Raft 是一种用来管理日志复制的一致性算法。
为了提高理解性，Raft 将一致性算法分为了几个部分，例如领导选取（leader selection），日志复制（log replication）和安全性（safety），同时它使用了更强的一致性来减少了必须需要考虑的状态。

相对于 Paxos，Raft 减少了非确定性的程度和服务器互相不一致的方式。

raft特性：
强领导者，例如日志只从领导者发送向其他服务器，这简化了对日志复制的管理。
领导选取，raft使用随机定时器来选取leader。这在心跳机制上加入了一点变化。
成员变化，Raft 为了调整集群中成员关系使用了新的联合一致性（joint consensus）的方法。

## 复制状态机
例如，GFS，HDFS还有 RAMCloud 这些大规模的系统都是用一个单独的集群领导者，使用一个单独的复制状态机来进行领导选取和存储配置信息来应对领导者的崩溃。使用复制状态机的例子有 Chubby 和 ZooKeeper。

复制状态机是通过复制日志来实现的。每一台服务器保存着一份日志，日志中包含一系列的命令，状态机会按顺序执行这些命令。因为每一台计算机的状态机都是确定的，所以每个状态机的状态都是相同的，执行的命令是相同的，最后的执行结果也就是一样的了。

在一台服务器上，一致性模块接受客户端的命令并且把命令加入到它的日志中。它和其他服务器上的一致性模块进行通信来确保每一个日志最终包含相同序列的请求，即使有一些服务器宕机了。一旦这些命令被正确的复制了，每一个服务器的状态机都会按同样的顺序去执行它们，然后将结果返回给客户端。

## paxos的不足
第一个是 Paxos 太难以理解。Paxos 的第二个缺点是它难以在实际环境中实现。

在raft中，我们将问题分解为leader election, log replication, safety, membership changes

通过减少需要考虑的状态数将状态空间简化，使得整个系统更加一致。

## raft算法
#### 状态
在所有服务器上持久存在的：
    currentTerm:  服务器最后知道的任期号（从0开始递增）
    votedFor: 当前任期内收到选票的候选人id (没有就为null)
    log[]: 日志条目；每个条目包含状态机的要执行命令和从领导人处收到时的任期号

在所有服务器上不稳定存在的：
    commitIndex: 已知被提交的最大日志条目的索引
    lastApplied: 被状态机执行的最大日志条目的索引

在领导人服务器上不稳定存在的：
    nextIndex[] 对于每个服务器，记录需要发给它的下一个日志条目的索引
    matchIndex[] 对于每个服务器，记录以及复制到改服务器的日志的最高索引值

AppendEntries RPC
由领导人来调用复制日志，也会用作heartbeat
    term: 领导人的任期号
    leaderId：领导人的id，为了其他服务器能重定向到客户端
    prevLogIndex: 最新日志之前的日志的索引值
    prevLogTerm: 最新日志之前的日志的领导人任期号
    entries[]: 将要存储的日志条目（）表示heartbeat时为空
    leaderCommit: 领导人提交的日志条目索引值
返回:
    term: 当前的任期号，用于领导人更新自己的任期号
    success: 如果其他服务器包含能够匹配上prevLogIndex和prevLogTerm的日志时为真

接受者需要实现：
如果 term < currentTerm返回 false（5.1节）
如果在prevLogIndex处的日志的任期号与prevLogTerm不匹配时，返回 false（5.3节）
如果一条已经存在的日志与新的冲突（index 相同但是任期号 term 不同），则删除已经存在的日志和它之后所有的日志（5.3节）
添加任何在已有的日志中不存在的条目
如果leaderCommit > commitIndex，将commitIndex设置为leaderCommit和最新日志条目索引号中较小的一个


## 投票rpc
